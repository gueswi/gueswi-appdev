# FIX CR√çTICO: Desfase de 1 d√≠a en c√°lculo de dayOfWeek

El problema: Cuando el usuario selecciona Martes 7, el sistema muestra horarios del Lunes 6.

**Causa:** El parsing de fecha no est√° manejando correctamente la zona horaria al calcular el d√≠a de la semana.

En `server/routes.ts`, **REEMPLAZAR** el endpoint `/api/calendar/available-slots`:
```typescript
app.get("/api/calendar/available-slots", async (req, res) => {
  try {
    const { serviceId, staffId, date, locationId } = req.query;

    if (!serviceId || !staffId || !date || !locationId) {
      return res.status(400).json({ error: "Missing parameters" });
    }

    const service = await db.query.services.findFirst({
      where: eq(schema.services.id, serviceId as string),
    });

    if (!service) {
      return res.status(404).json({ error: "Service not found" });
    }

    const staff = await db.query.staffMembers.findFirst({
      where: eq(schema.staffMembers.id, staffId as string),
    });

    if (!staff) {
      return res.status(404).json({ error: "Staff not found" });
    }

    let schedules = staff.schedulesByLocation;
    if (typeof schedules === "string") {
      try {
        schedules = JSON.parse(schedules);
      } catch {
        return res.json({ slots: [] });
      }
    }

    if (!schedules) {
      return res.json({ slots: [] });
    }

    const locationSchedule = schedules[locationId as string];
    if (!locationSchedule) {
      return res.json({ slots: [] });
    }

    // Parsear fecha robustamente
    let dateStr = date as string;
    if (dateStr.includes("T")) {
      dateStr = dateStr.split("T")[0];
    }
    
    const [year, month, day] = dateStr.split("-").map(Number);
    
    const MADRID_OFFSET_HOURS = 2;
    
    // CR√çTICO: Calcular d√≠a de semana directamente del string de fecha
    // Martes 7 oct 2025 ‚Üí dayOfWeek debe ser 2
    const dayOfWeek = new Date(year, month - 1, day).getDay();
    
    console.log(`üìÖ Date: ${dateStr}, Day of week: ${dayOfWeek} (${['Dom','Lun','Mar','Mi√©','Jue','Vie','S√°b'][dayOfWeek]})`);
    
    const daySchedule = locationSchedule[dayOfWeek];

    if (!daySchedule?.enabled || !daySchedule.blocks) {
      console.log(`‚ùå No schedule for day ${dayOfWeek}`);
      return res.json({ slots: [] });
    }

    console.log(`‚úÖ Schedule blocks:`, daySchedule.blocks);

    // Inicio y fin del d√≠a en Madrid, convertido a UTC
    const startOfDayMadrid = new Date(Date.UTC(
      year, 
      month - 1, 
      day, 
      0 - MADRID_OFFSET_HOURS, 
      0, 
      0, 
      0
    ));
    
    const endOfDayMadrid = new Date(Date.UTC(
      year, 
      month - 1, 
      day, 
      23 - MADRID_OFFSET_HOURS, 
      59, 
      59, 
      999
    ));

    const existingAppointments = await db.query.appointments.findMany({
      where: and(
        eq(schema.appointments.staffId, staffId as string),
        eq(schema.appointments.locationId, locationId as string),
        gte(schema.appointments.startTime, startOfDayMadrid),
        lte(schema.appointments.startTime, endOfDayMadrid),
        ne(schema.appointments.status, "cancelled")
      ),
    });

    const slots: any[] = [];
    const serviceDuration = service.duration;
    const nowUTC = new Date();
    const nowMadrid = new Date(nowUTC.getTime() + (MADRID_OFFSET_HOURS * 60 * 60 * 1000));

    daySchedule.blocks.forEach((block: any, blockIdx: number) => {
      const [startH, startM] = block.start.split(":").map(Number);
      const [endH, endM] = block.end.split(":").map(Number);

      console.log(`üîç Processing block ${blockIdx}: ${block.start}-${block.end}`);

      // Crear fecha en Madrid y luego convertir a UTC
      const blockStartMadrid = new Date(year, month - 1, day, startH, startM, 0, 0);
      const blockEndMadrid = new Date(year, month - 1, day, endH, endM, 0, 0);
      
      // Convertir a UTC restando offset
      let currentTimeUTC = new Date(blockStartMadrid.getTime() - (MADRID_OFFSET_HOURS * 60 * 60 * 1000));
      const blockEndUTC = new Date(blockEndMadrid.getTime() - (MADRID_OFFSET_HOURS * 60 * 60 * 1000));

      while (currentTimeUTC < blockEndUTC) {
        const slotEndUTC = new Date(currentTimeUTC);
        slotEndUTC.setUTCMinutes(slotEndUTC.getUTCMinutes() + serviceDuration);

        if (slotEndUTC <= blockEndUTC) {
          // Convertir slot UTC a Madrid para comparar con "ahora" en Madrid
          const slotStartMadrid = new Date(currentTimeUTC.getTime() + (MADRID_OFFSET_HOURS * 60 * 60 * 1000));
          const isFuture = slotStartMadrid.getTime() >= nowMadrid.getTime();

          const isOccupied = existingAppointments.some((apt) => {
            const aptStart = new Date(apt.startTime);
            const aptEnd = new Date(apt.endTime);
            return (
              (currentTimeUTC >= aptStart && currentTimeUTC < aptEnd) ||
              (slotEndUTC > aptStart && slotEndUTC <= aptEnd) ||
              (currentTimeUTC <= aptStart && slotEndUTC >= aptEnd)
            );
          });

          if (isFuture && !isOccupied) {
            slots.push({
              startTime: currentTimeUTC.toISOString(),
              endTime: slotEndUTC.toISOString(),
            });
          }
        }

        currentTimeUTC.setUTCMinutes(currentTimeUTC.getUTCMinutes() + serviceDuration);
      }
    });

    console.log(`‚úÖ Generated ${slots.length} slots`);

    res.json({ slots });
  } catch (error: any) {
    console.error("‚ùå Slots error:", error);
    res.status(500).json({ error: error.message });
  }
});