# CORRECCI√ìN: Horarios de Personal m√°s Flexibles

## Problema Actual
En el formulario de "Agregar Personal", al definir horarios por ubicaci√≥n, el sistema valida que las horas del staff deben estar dentro del horario de la ubicaci√≥n, pero los inputs vienen pre-poblados con el horario completo de la ubicaci√≥n y no permiten editarse libremente.

**Ejemplo del problema:**
- Ubicaci√≥n trabaja: Lunes 9:00 - 17:00
- Juan solo trabaja: Lunes 10:00 - 12:00
- Actualmente NO se puede configurar esto correctamente

## Soluci√≥n Requerida

### CAMBIO #1: En `client/src/components/bookings/staff-manager.tsx`

**Modificar la funci√≥n `toggleDay` para NO pre-poblar con el horario de la ubicaci√≥n:**
```typescript
const toggleDay = (locationId: string, dayIndex: number) => {
  const location = locations?.find((l: any) => l.id === locationId);
  const locationDaySchedule = location?.operatingHours?.[dayIndex];

  if (!locationDaySchedule?.enabled) {
    toast({
      title: "D√≠a no disponible",
      description: `Esta ubicaci√≥n no opera los ${DAYS[dayIndex]}`,
      variant: "destructive",
    });
    return;
  }

  const newSchedules = { ...schedulesByLocation };
  if (newSchedules[locationId][dayIndex].enabled) {
    // Deshabilitar
    newSchedules[locationId][dayIndex] = { enabled: false, blocks: [] };
  } else {
    // Habilitar con horario VAC√çO para que el usuario defina su propio horario
    newSchedules[locationId][dayIndex] = {
      enabled: true,
      blocks: [{ start: "09:00", end: "17:00" }], // Valores por defecto editables
    };
  }
  setSchedulesByLocation(newSchedules);
};
Modificar la funci√≥n updateBlock para validar RANGO en lugar de valores exactos:
typescriptconst updateBlock = (locationId: string, dayIndex: number, blockIndex: number, field: "start" | "end", value: string) => {
  const location = locations?.find((l: any) => l.id === locationId);
  const locationDaySchedule = location?.operatingHours?.[dayIndex];

  // Convertir el valor ingresado a minutos
  const [inputH, inputM] = value.split(":").map(Number);
  const inputMinutes = inputH * 60 + inputM;

  // Obtener el rango completo de la ubicaci√≥n (de todos sus bloques)
  const locationMinStart = Math.min(
    ...locationDaySchedule.blocks.map((b: any) => {
      const [h, m] = b.start.split(":").map(Number);
      return h * 60 + m;
    })
  );

  const locationMaxEnd = Math.max(
    ...locationDaySchedule.blocks.map((b: any) => {
      const [h, m] = b.end.split(":").map(Number);
      return h * 60 + m;
    })
  );

  // NUEVA VALIDACI√ìN: Verificar que est√© DENTRO del rango de la ubicaci√≥n
  if (inputMinutes < locationMinStart || inputMinutes > locationMaxEnd) {
    const minTime = `${String(Math.floor(locationMinStart / 60)).padStart(2, "0")}:${String(locationMinStart % 60).padStart(2, "0")}`;
    const maxTime = `${String(Math.floor(locationMaxEnd / 60)).padStart(2, "0")}:${String(locationMaxEnd % 60).padStart(2, "0")}`;
    
    toast({
      title: "Horario fuera de rango",
      description: `El horario debe estar entre ${minTime} y ${maxTime} (horario de la ubicaci√≥n)`,
      variant: "destructive",
    });
    return;
  }

  const newSchedules = { ...schedulesByLocation };
  const block = newSchedules[locationId][dayIndex].blocks[blockIndex];
  block[field] = value;

  // Validar start < end
  if (block.start >= block.end) {
    toast({
      title: "Horario inv√°lido",
      description: "La hora de inicio debe ser menor que la de fin",
      variant: "destructive",
    });
    return;
  }

  // Validar que no se solape con otros bloques del mismo staff
  const blocks = newSchedules[locationId][dayIndex].blocks;
  for (let i = 0; i < blocks.length; i++) {
    if (i === blockIndex) continue;
    
    const otherBlock = blocks[i];
    const [otherStartH, otherStartM] = otherBlock.start.split(":").map(Number);
    const [otherEndH, otherEndM] = otherBlock.end.split(":").map(Number);
    const otherStart = otherStartH * 60 + otherStartM;
    const otherEnd = otherEndH * 60 + otherEndM;
    
    const [currStartH, currStartM] = block.start.split(":").map(Number);
    const [currEndH, currEndM] = block.end.split(":").map(Number);
    const currStart = currStartH * 60 + currStartM;
    const currEnd = currEndH * 60 + currEndM;
    
    // Verificar solapamiento
    if ((currStart < otherEnd && currEnd > otherStart)) {
      toast({
        title: "Horario inv√°lido",
        description: "Los bloques de horario no pueden solaparse",
        variant: "destructive",
      });
      return;
    }
  }

  setSchedulesByLocation(newSchedules);
};
Agregar mensaje informativo en el UI:
En el formulario de StaffManager, dentro del Card de cada ubicaci√≥n, agregar este mensaje:
typescript<Card key={locationId} className="p-4 bg-blue-50">
  <h4 className="font-semibold mb-1">Horario en: {location?.name}</h4>
  
  {/* NUEVO: Mostrar horario de la ubicaci√≥n como referencia */}
  <p className="text-xs text-muted-foreground mb-3">
    üìç Horario de la ubicaci√≥n: {" "}
    {Object.entries(location?.operatingHours || {})
      .filter(([_, schedule]: any) => schedule?.enabled)
      .map(([day, schedule]: any) => {
        const dayName = DAYS[parseInt(day)].substring(0, 3);
        const blocks = schedule.blocks
          .map((b: any) => `${b.start}-${b.end}`)
          .join(", ");
        return `${dayName}: ${blocks}`;
      })
      .join(" ‚Ä¢ ")}
  </p>
  <p className="text-xs text-blue-600 mb-3">
    üí° Puedes definir cualquier horario dentro del rango de la ubicaci√≥n
  </p>
  
  {/* ... resto del c√≥digo de d√≠as y bloques ... */}
</Card>

CAMBIO #2: Validaci√≥n Backend m√°s Flexible
En server/routes.ts, actualizar la funci√≥n de validaci√≥n:
typescript// En POST /api/calendar/appointments, modificar la validaci√≥n de staff:

const staffSchedules = staff.schedulesByLocation as any;
const staffScheduleForLocation = staffSchedules?.[locationId];

if (!staffScheduleForLocation) {
  return res.status(400).json({
    error: "Staff member does not work at this location",
  });
}

const staffDaySchedule = staffScheduleForLocation[start.getDay()];
if (!staffDaySchedule?.enabled) {
  return res.status(400).json({
    error: "Staff member does not work on this day at this location",
  });
}

const startMinutes = start.getHours() * 60 + start.getMinutes();
const endMinutes = end.getHours() * 60 + end.getMinutes();

// Verificar que la cita est√© dentro de ALGUNO de los bloques del staff
const staffWorksInTimeRange = staffDaySchedule.blocks?.some((block: any) => {
  const [startH, startM] = block.start.split(":").map(Number);
  const [endH, endM] = block.end.split(":").map(Number);
  const blockStart = startH * 60 + startM;
  const blockEnd = endH * 60 + endM;
  
  // La cita debe estar COMPLETAMENTE dentro del bloque del staff
  return startMinutes >= blockStart && endMinutes <= blockEnd;
});

if (!staffWorksInTimeRange) {
  return res.status(400).json({
    error: "Staff member is not available at this time. Check their schedule.",
  });
}

‚úÖ RESULTADO ESPERADO
Despu√©s de estos cambios:

‚úÖ Al habilitar un d√≠a para un staff member, los campos de hora estar√°n editables libremente
‚úÖ El sistema validar√° que las horas est√©n DENTRO del rango de la ubicaci√≥n (no exactamente iguales)
‚úÖ Juan puede trabajar Lunes 10:00-12:00 si la ubicaci√≥n trabaja 9:00-17:00
‚úÖ El sistema mostrar√° mensaje claro del horario de la ubicaci√≥n como referencia
‚úÖ Backend validar√° que las citas respeten el horario espec√≠fico del staff