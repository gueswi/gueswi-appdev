Implementa funcionalidad de MÚLTIPLES PIPELINES en el módulo CRM.

Actualmente hay 1 pipeline por tenant. Necesitamos que cada tenant pueda crear múltiples pipelines (ej: Ventas Equipo A, Ventas Equipo B, Barcelona, Madrid).

Cada pipeline tiene sus propias etapas personalizadas independientes.

PASO 1: ESQUEMA DE BASE DE DATOS (shared/schema.ts)

Agrega tabla pipelines ANTES de pipelineStages:

export const pipelines = pgTable("pipelines", {
  id: uuid("id").defaultRandom().primaryKey(),
  tenantId: uuid("tenant_id").notNull(),
  name: text("name").notNull(),
  description: text("description"),
  isDefault: boolean("is_default").default(false),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

Modifica pipelineStages para agregar pipeline_id:

export const pipelineStages = pgTable("pipeline_stages", {
  id: uuid("id").defaultRandom().primaryKey(),
  tenantId: uuid("tenant_id").notNull(),
  pipelineId: uuid("pipeline_id").notNull(), // AGREGAR
  name: text("name").notNull(),
  order: integer("order").notNull(),
  color: text("color").default("#3b82f6"),
  isFixed: boolean("is_fixed").default(false),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

Modifica leads para agregar pipeline_id:

export const leads = pgTable("leads", {
  id: uuid("id").defaultRandom().primaryKey(),
  tenantId: uuid("tenant_id").notNull(),
  pipelineId: uuid("pipeline_id").notNull(), // AGREGAR
  stageId: uuid("stage_id").notNull(),
  // ... resto igual
});

PASO 2: MIGRACIÓN SQL (drizzle/0005_multiple_pipelines.sql)

CREATE TABLE IF NOT EXISTS pipelines (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL,
  name TEXT NOT NULL,
  description TEXT,
  is_default BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMP DEFAULT NOW() NOT NULL
);

-- Agregar pipeline_id a tablas existentes
ALTER TABLE pipeline_stages ADD COLUMN IF NOT EXISTS pipeline_id UUID;
ALTER TABLE leads ADD COLUMN IF NOT EXISTS pipeline_id UUID;

-- Crear pipeline "default" para cada tenant existente
INSERT INTO pipelines (tenant_id, name, is_default)
SELECT DISTINCT tenant_id, 'Pipeline Principal', true
FROM pipeline_stages
WHERE tenant_id IS NOT NULL
ON CONFLICT DO NOTHING;

-- Asignar pipeline_id a etapas existentes
UPDATE pipeline_stages ps
SET pipeline_id = (
  SELECT id FROM pipelines p 
  WHERE p.tenant_id = ps.tenant_id AND p.is_default = true
  LIMIT 1
)
WHERE pipeline_id IS NULL;

-- Asignar pipeline_id a leads existentes
UPDATE leads l
SET pipeline_id = (
  SELECT id FROM pipelines p 
  WHERE p.tenant_id = l.tenant_id AND p.is_default = true
  LIMIT 1
)
WHERE pipeline_id IS NULL;

-- Hacer NOT NULL después de migrar datos
ALTER TABLE pipeline_stages ALTER COLUMN pipeline_id SET NOT NULL;
ALTER TABLE leads ALTER COLUMN pipeline_id SET NOT NULL;

PASO 3: BACKEND ENDPOINTS (server/routes.ts)

Agrega estos endpoints ANTES de los endpoints de stages:

// Pipelines CRUD
app.get("/api/pipelines", async (req, res) => {
  if (!req.isAuthenticated() || !req.user.tenantId) {
    return res.sendStatus(401);
  }

  try {
    const pipelines = await db
      .select()
      .from(schema.pipelines)
      .where(eq(schema.pipelines.tenantId, req.user.tenantId))
      .orderBy(desc(schema.pipelines.isDefault), schema.pipelines.createdAt);
    
    res.json(pipelines);
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

app.post("/api/pipelines", async (req, res) => {
  if (!req.isAuthenticated() || !req.user.tenantId) {
    return res.sendStatus(401);
  }

  try {
    const { name, description } = req.body;
    
    const [newPipeline] = await db
      .insert(schema.pipelines)
      .values({
        tenantId: req.user.tenantId,
        name,
        description,
        isDefault: false,
      })
      .returning();

    // Crear etapas base para el nuevo pipeline
    const defaultStages = [
      { name: "Nuevo", order: 0, color: "#10b981", isFixed: false },
      { name: "Contactado", order: 1, color: "#3b82f6", isFixed: false },
      { name: "Calificado", order: 2, color: "#8b5cf6", isFixed: false },
      { name: "Propuesta", order: 3, color: "#f59e0b", isFixed: false },
      { name: "Negociación", order: 4, color: "#ef4444", isFixed: false },
      { name: "Ganado", order: 5, color: "#22c55e", isFixed: true },
      { name: "Perdido", order: 6, color: "#6b7280", isFixed: true },
    ];

    for (const stage of defaultStages) {
      await db.insert(schema.pipelineStages).values({
        tenantId: req.user.tenantId,
        pipelineId: newPipeline.id,
        ...stage,
      });
    }

    res.json(newPipeline);
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

app.patch("/api/pipelines/:id", async (req, res) => {
  if (!req.isAuthenticated() || !req.user.tenantId) {
    return res.sendStatus(401);
  }

  try {
    const { id } = req.params;
    const { name, description } = req.body;

    await db
      .update(schema.pipelines)
      .set({ name, description, updatedAt: new Date() })
      .where(
        and(
          eq(schema.pipelines.id, id),
          eq(schema.pipelines.tenantId, req.user.tenantId)
        )
      );

    res.json({ success: true });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

app.delete("/api/pipelines/:id", async (req, res) => {
  if (!req.isAuthenticated() || !req.user.tenantId) {
    return res.sendStatus(401);
  }

  try {
    const { id } = req.params;

    // Verificar que no es default
    const pipeline = await db.query.pipelines.findFirst({
      where: and(
        eq(schema.pipelines.id, id),
        eq(schema.pipelines.tenantId, req.user.tenantId)
      ),
    });

    if (pipeline?.isDefault) {
      return res.status(400).json({ error: "No puedes eliminar el pipeline principal" });
    }

    // Verificar que no tiene leads
    const leadsCount = await db
      .select({ count: sql<number>`count(*)` })
      .from(schema.leads)
      .where(eq(schema.leads.pipelineId, id));

    if (leadsCount[0]?.count > 0) {
      return res.status(400).json({ 
        error: `Este pipeline tiene ${leadsCount[0].count} leads. Muévelos o elimínalos primero.` 
      });
    }

    // Eliminar stages
    await db
      .delete(schema.pipelineStages)
      .where(eq(schema.pipelineStages.pipelineId, id));

    // Eliminar pipeline
    await db
      .delete(schema.pipelines)
      .where(eq(schema.pipelines.id, id));

    res.json({ success: true });
  } catch (error: any) {
    res.status(500).json({ error: error.message });
  }
});

Modifica TODOS los endpoints existentes de stages, leads y metrics para filtrar por pipeline_id:

- GET /api/pipeline/stages: agregar WHERE pipeline_id = ?
- GET /api/pipeline/leads: agregar WHERE pipeline_id = ?
- GET /api/pipeline/metrics: filtrar por pipeline_id
- POST /api/pipeline/stages: agregar pipeline_id al insert
- POST /api/pipeline/leads: agregar pipeline_id al insert

PASO 4: FRONTEND - Selector de Pipeline (client/src/pages/pipeline-page.tsx)

Línea ~40, agrega state para pipeline seleccionado:

const [selectedPipelineId, setSelectedPipelineId] = useState<string | null>(null);

Línea ~45, agrega query de pipelines:

const { data: pipelines = [] } = useQuery<any[]>({
  queryKey: ["/api/pipelines"],
});

Línea ~50, modifica query de stages para filtrar por pipeline:

const { data: stages = [], isLoading: stagesLoading } = useQuery<PipelineStage[]>({
  queryKey: ["/api/pipeline/stages", selectedPipelineId],
  enabled: !!selectedPipelineId,
});

Línea ~55, modifica query de leads:

const { data: leads = [], isLoading: leadsLoading } = useQuery<Lead[]>({
  queryKey: ["/api/pipeline/leads", selectedPipelineId],
  enabled: !!selectedPipelineId,
});

Línea ~60, modifica query de metrics:

const { data: metrics } = useQuery({
  queryKey: ["/api/pipeline/metrics", selectedPipelineId],
  enabled: !!selectedPipelineId,
});

Línea ~80, useEffect para seleccionar pipeline default:

useEffect(() => {
  if (pipelines.length > 0 && !selectedPipelineId) {
    const defaultPipeline = pipelines.find(p => p.isDefault) || pipelines[0];
    setSelectedPipelineId(defaultPipeline.id);
  }
}, [pipelines, selectedPipelineId]);

Línea ~130, en el header, agrega selector ANTES de los botones:

<div className="flex items-center justify-between mb-4">
  <div className="flex items-center gap-4">
    <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
      Pipeline de Ventas
    </h1>
    <Select value={selectedPipelineId || ""} onValueChange={setSelectedPipelineId}>
      <SelectTrigger className="w-64">
        <SelectValue placeholder="Selecciona pipeline" />
      </SelectTrigger>
      <SelectContent>
        {pipelines.map((pipeline) => (
          <SelectItem key={pipeline.id} value={pipeline.id}>
            {pipeline.name} {pipeline.isDefault && "(Principal)"}
          </SelectItem>
        ))}
      </SelectContent>
    </Select>
    <PipelinesManagerDialog />
  </div>
  <div className="flex items-center gap-2">
    <StagesEditorDialog stages={sortedStages} leads={leads} pipelineId={selectedPipelineId} />
    <NewLeadDialog stages={sortedStages} pipelineId={selectedPipelineId} />
  </div>
</div>

PASO 5: Componente Gestor de Pipelines (client/src/components/pipeline/pipelines-manager-dialog.tsx)

Crea nuevo archivo con modal CRUD de pipelines:
- Lista de pipelines existentes
- Botón "Nuevo Pipeline"
- Para cada pipeline: botón editar nombre, botón eliminar (si no es default y no tiene leads)
- Validaciones

PASO 6: Actualizar componentes existentes

En new-lead-dialog.tsx: agregar prop pipelineId y enviarlo al crear lead
En stages-editor-dialog.tsx: agregar prop pipelineId y filtrar/crear stages del pipeline actual

Implementa TODO esto de forma completa y funcional. Testea creando un segundo pipeline y verificando que stages y leads están separados.