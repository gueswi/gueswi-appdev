Veo 4 bugs cr√≠ticos que indican que el endpoint de slots y las eliminaciones no est√°n funcionando correctamente. Analicemos:
üî¥ Bugs Identificados
Bug #1: Calendario no pre-selecciona el d√≠a clickeado desde el calendario principal
Bug #2: NING√öN horario se muestra (el problema principal que seguimos teniendo)
Bug #3: Error al eliminar personal (error de parsing JSON)
Bug #4: Error al eliminar ubicaci√≥n (mismo error)
El bug #2 es el m√°s grave - sugiere que el endpoint /api/calendar/available-slots est√° fallando completamente o retornando datos vac√≠os.

PROMPT MEGA-DEBUG Y CORRECCI√ìN DEFINITIVA
markdown# DEBUG COMPLETO Y CORRECCI√ìN DE BUGS CR√çTICOS - RESERVAS

## üî¥ BUGS IDENTIFICADOS

1. Fecha no se pre-selecciona en calendario del modal
2. **CR√çTICO**: Slots NUNCA se muestran para ninguna combinaci√≥n
3. Error al eliminar personal (JSON parse error)
4. Error al eliminar ubicaci√≥n (JSON parse error)

---

## SOLUCI√ìN BUG #2 (CR√çTICO): Slots no se muestran

### Paso 1: Agregar logging exhaustivo al endpoint

En `server/routes.ts`, REEMPLAZAR COMPLETAMENTE el endpoint `/api/calendar/available-slots`:
```typescript
app.get("/api/calendar/available-slots", async (req, res) => {
  console.log("\nüîç ===== AVAILABLE SLOTS REQUEST =====");
  console.log("Query params:", req.query);

  try {
    const { serviceId, staffId, date, locationId } = req.query;

    if (!serviceId || !staffId || !date || !locationId) {
      console.log("‚ùå Missing parameters");
      return res.status(400).json({ error: "Missing required parameters" });
    }

    // Obtener servicio
    const service = await db.query.services.findFirst({
      where: eq(schema.services.id, serviceId as string),
    });

    console.log("üì¶ Service:", service);

    if (!service) {
      console.log("‚ùå Service not found");
      return res.status(404).json({ error: "Service not found" });
    }

    // Obtener staff
    const staff = await db.query.staffMembers.findFirst({
      where: eq(schema.staffMembers.id, staffId as string),
    });

    console.log("üë§ Staff raw:", {
      id: staff?.id,
      name: staff?.name,
      schedulesByLocation: staff?.schedulesByLocation,
      schedulesByLocationType: typeof staff?.schedulesByLocation
    });

    if (!staff) {
      console.log("‚ùå Staff not found");
      return res.status(404).json({ error: "Staff not found" });
    }

    // CR√çTICO: Parsear schedulesByLocation
    let staffSchedules = staff.schedulesByLocation;
    
    console.log("üîç schedulesByLocation BEFORE parse:", staffSchedules);
    console.log("üîç Type:", typeof staffSchedules);

    if (typeof staffSchedules === "string") {
      try {
        staffSchedules = JSON.parse(staffSchedules);
        console.log("‚úÖ Parsed schedules:", staffSchedules);
      } catch (e) {
        console.error("‚ùå Failed to parse staff schedules:", e);
        return res.json({ slots: [] });
      }
    }

    if (!staffSchedules || typeof staffSchedules !== 'object') {
      console.log("‚ùå Invalid schedules format");
      return res.json({ slots: [] });
    }

    // Verificar ubicaci√≥n
    const staffScheduleForLocation = staffSchedules[locationId as string];
    console.log("üîç Schedule for location:", staffScheduleForLocation);

    if (!staffScheduleForLocation) {
      console.log("‚ùå Staff does not work at this location");
      return res.json({ slots: [] });
    }

    // Parsear fecha
    const requestedDate = new Date(date as string + "T00:00:00");
    const dayOfWeek = requestedDate.getDay();

    console.log("üìÖ Requested date:", requestedDate);
    console.log("üìÖ Day of week:", dayOfWeek, ["Dom", "Lun", "Mar", "Mi√©", "Jue", "Vie", "S√°b"][dayOfWeek]);

    // Verificar d√≠a
    const staffDaySchedule = staffScheduleForLocation[dayOfWeek];
    console.log("üîç Staff schedule for this day:", staffDaySchedule);

    if (!staffDaySchedule || !staffDaySchedule.enabled) {
      console.log("‚ùå Staff does not work on this day");
      return res.json({ slots: [] });
    }

    if (!staffDaySchedule.blocks || !Array.isArray(staffDaySchedule.blocks)) {
      console.log("‚ùå No blocks defined");
      return res.json({ slots: [] });
    }

    console.log("‚úÖ Staff works on this day, blocks:", staffDaySchedule.blocks);

    // Obtener citas existentes
    const startOfDay = new Date(requestedDate);
    startOfDay.setHours(0, 0, 0, 0);
    const endOfDay = new Date(requestedDate);
    endOfDay.setHours(23, 59, 59, 999);

    const existingAppointments = await db.query.appointments.findMany({
      where: and(
        eq(schema.appointments.staffId, staffId as string),
        eq(schema.appointments.locationId, locationId as string),
        gte(schema.appointments.startTime, startOfDay),
        lte(schema.appointments.startTime, endOfDay),
        ne(schema.appointments.status, "cancelled")
      ),
    });

    console.log("üìã Existing appointments:", existingAppointments.length);

    // Generar slots
    const slots: any[] = [];
    const slotDuration = service.duration;
    const now = new Date();

    console.log("‚è±Ô∏è Slot duration:", slotDuration, "minutes");

    staffDaySchedule.blocks.forEach((block: any, idx: number) => {
      console.log(`\nüîç Processing block ${idx}:`, block);

      const [startH, startM] = block.start.split(":").map(Number);
      const [endH, endM] = block.end.split(":").map(Number);

      let currentTime = new Date(requestedDate);
      currentTime.setHours(startH, startM, 0, 0);

      const blockEnd = new Date(requestedDate);
      blockEnd.setHours(endH, endM, 0, 0);

      console.log(`   Block range: ${currentTime.toISOString()} ‚Üí ${blockEnd.toISOString()}`);

      let slotCount = 0;

      while (currentTime < blockEnd) {
        const slotEnd = new Date(currentTime);
        slotEnd.setMinutes(slotEnd.getMinutes() + slotDuration);

        if (slotEnd <= blockEnd) {
          const isOccupied = existingAppointments.some((apt) => {
            const aptStart = new Date(apt.startTime);
            const aptEnd = new Date(apt.endTime);
            return (
              (currentTime >= aptStart && currentTime < aptEnd) ||
              (slotEnd > aptStart && slotEnd <= aptEnd) ||
              (currentTime <= aptStart && slotEnd >= aptEnd)
            );
          });

          const isFuture = currentTime > now;

          if (isFuture && !isOccupied) {
            slots.push({
              startTime: currentTime.toISOString(),
              endTime: slotEnd.toISOString(),
            });
            slotCount++;
            console.log(`   ‚úÖ Slot ${slotCount}: ${currentTime.toLocaleTimeString('es')}`);
          } else {
            console.log(`   ‚è≠Ô∏è  Skip: ${currentTime.toLocaleTimeString('es')} (${!isFuture ? 'past' : 'occupied'})`);
          }
        }

        currentTime.setMinutes(currentTime.getMinutes() + 30);
      }

      console.log(`   Block total slots: ${slotCount}`);
    });

    console.log(`\n‚úÖ TOTAL SLOTS GENERATED: ${slots.length}`);
    console.log("üîç ===== END REQUEST =====\n");

    res.json({ slots });
  } catch (error: any) {
    console.error("‚ùå ERROR:", error);
    res.status(500).json({ error: error.message });
  }
});
Paso 2: Verificar que GET staff parsea correctamente
En server/routes.ts, endpoint GET /api/calendar/staff:
typescriptapp.get("/api/calendar/staff", async (req, res) => {
  if (!req.isAuthenticated() || !req.user.tenantId) {
    return res.sendStatus(401);
  }

  try {
    const staff = await db.query.staffMembers.findMany({
      where: eq(schema.staffMembers.tenantId, req.user.tenantId),
      with: {
        staffServices: { with: { service: true } },
        location: true,
      },
      orderBy: [asc(schema.staffMembers.name)],
    });

    // PARSEAR schedulesByLocation
    const staffParsed = staff.map((s: any) => {
      let schedules = s.schedulesByLocation;
      
      if (typeof schedules === 'string') {
        try {
          schedules = JSON.parse(schedules);
        } catch (e) {
          console.error("‚ùå Parse error for staff:", s.id, e);
          schedules = {};
        }
      }

      return {
        ...s,
        schedulesByLocation: schedules || {}
      };
    });

    res.json(staffParsed);
  } catch (error: any) {
    console.error("‚ùå Error fetching staff:", error);
    res.status(500).json({ error: error.message });
  }
});

SOLUCI√ìN BUG #1: Pre-seleccionar fecha en calendario
En client/src/components/bookings/weekly-slot-picker.tsx:
typescriptconst [currentWeekStart, setCurrentWeekStart] = useState<Date>(() => {
  const base = initialDate || new Date();
  const day = base.getDay();
  const diff = base.getDate() - day + (day === 0 ? -6 : 1);
  const monday = new Date(base);
  monday.setDate(diff);
  monday.setHours(0, 0, 0, 0);
  return monday;
});

const [selectedDayIndex, setSelectedDayIndex] = useState<number>(() => {
  if (initialDate) {
    const dayOfWeek = initialDate.getDay();
    return dayOfWeek === 0 ? 6 : dayOfWeek - 1;
  }
  const today = new Date().getDay();
  return today === 0 ? 6 : today - 1;
});

// Actualizar cuando cambia initialDate
useEffect(() => {
  if (initialDate) {
    const dayOfWeek = initialDate.getDay();
    setSelectedDayIndex(dayOfWeek === 0 ? 6 : dayOfWeek - 1);
    
    // Ajustar semana si es necesario
    const day = initialDate.getDay();
    const diff = initialDate.getDate() - day + (day === 0 ? -6 : 1);
    const monday = new Date(initialDate);
    monday.setDate(diff);
    monday.setHours(0, 0, 0, 0);
    setCurrentWeekStart(monday);
  }
}, [initialDate]);

SOLUCI√ìN BUG #3 y #4: Errores al eliminar
Los errores de "<!DOCTYPE... is not valid JSON" significan que el endpoint est√° retornando HTML en lugar de JSON (probablemente una p√°gina de error).
En server/routes.ts, verificar endpoints DELETE:
typescript// DELETE staff
app.delete("/api/calendar/staff/:id", async (req, res) => {
  if (!req.isAuthenticated() || !req.user.tenantId) {
    return res.sendStatus(401);
  }

  try {
    const staffId = req.params.id;

    // Eliminar relaciones primero
    await db.delete(schema.staffServices)
      .where(eq(schema.staffServices.staffId, staffId));

    // Eliminar staff
    await db.delete(schema.staffMembers)
      .where(and(
        eq(schema.staffMembers.id, staffId),
        eq(schema.staffMembers.tenantId, req.user.tenantId)
      ));

    console.log("üë§ Staff deleted:", staffId);
    res.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error deleting staff:", error);
    res.status(500).json({ error: error.message });
  }
});

// DELETE location
app.delete("/api/calendar/locations/:id", async (req, res) => {
  if (!req.isAuthenticated() || !req.user.tenantId) {
    return res.sendStatus(401);
  }

  try {
    const locationId = req.params.id;

    // Validar dependencias
    const staffInLocation = await db.query.staffMembers.findMany({
      where: eq(schema.staffMembers.tenantId, req.user.tenantId),
    });

    const hasStaff = staffInLocation.some((staff: any) => {
      let schedules = staff.schedulesByLocation;
      if (typeof schedules === 'string') {
        schedules = JSON.parse(schedules);
      }
      return schedules && Object.keys(schedules).includes(locationId);
    });

    if (hasStaff) {
      return res.status(400).json({
        error: "No se puede eliminar: hay personal asignado a esta ubicaci√≥n"
      });
    }

    // Eliminar relaciones
    await db.delete(schema.serviceLocations)
      .where(eq(schema.serviceLocations.locationId, locationId));

    // Eliminar ubicaci√≥n
    await db.delete(schema.locations)
      .where(and(
        eq(schema.locations.id, locationId),
        eq(schema.locations.tenantId, req.user.tenantId)
      ));

    console.log("üìç Location deleted:", locationId);
    res.json({ success: true });
  } catch (error: any) {
    console.error("‚ùå Error deleting location:", error);
    res.status(500).json({ error: error.message });
  }
});

üß™ TESTING
Despu√©s de implementar:

Reinicia el servidor
Abre modal Nueva Cita
Selecciona ubicaci√≥n + servicio + personal
Revisa los logs del servidor en Replit - deber√≠as ver todos los logs con üîç
Copia TODOS los logs aqu√≠

Los logs me dir√°n exactamente d√≥nde est√° fallando.