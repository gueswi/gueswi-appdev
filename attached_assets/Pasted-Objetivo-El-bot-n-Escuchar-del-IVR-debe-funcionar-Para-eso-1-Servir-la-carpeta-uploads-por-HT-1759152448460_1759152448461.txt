Objetivo: El botón “Escuchar” del IVR debe funcionar. Para eso:
1) Servir la carpeta /uploads por HTTP
2) Generar y guardar un WAV (silencio) en /uploads/ivr cuando llamo a POST /api/ivr/tts
3) Devolver la URL real del archivo (p. ej. /uploads/ivr/xxx.wav)

### 1) Servir /uploads en Express
Edita `server/index.ts`. Justo después de estos middlewares:
  app.use(cookieParser());
  app.use(express.json());
  app.use(express.urlencoded({ extended: true }));

añade este bloque (IMPORTANTE: con imports al inicio del archivo):

  // --- BEGIN uploads static ---
  import path from "path";
  import fs from "fs";

  const uploadsDir = path.resolve("uploads");
  const ivrDir = path.join(uploadsDir, "ivr");
  try { fs.mkdirSync(ivrDir, { recursive: true }); } catch {}
  // Servir /uploads estáticamente (debe ir antes de Vite y antes del catch-all)
  app.use("/uploads", express.static(uploadsDir, { fallthrough: false }));
  // --- END uploads static ---

(Asegúrate de que los imports de path y fs estén presentes arriba del archivo; si ya existen, no los dupliques.)

### 2) Reemplazar handler de POST /api/ivr/tts
En `server/routes.ts` busca la ruta existente:
  app.post("/api/ivr/tts", async (req, res) => { ... })

y REEMPLÁZALA COMPLETA por esto:

  // TTS (Text-to-Speech) mock: generar WAV de silencio y guardarlo en /uploads/ivr
  import fs from "fs";
  import path from "path";

  function makeSilentWav(seconds = 2, sampleRate = 8000) {
    const numChannels = 1;
    const bitsPerSample = 16;
    const numSamples = Math.max(1, Math.floor(seconds * sampleRate));
    const dataSize = numSamples * numChannels * (bitsPerSample / 8);
    const buffer = Buffer.alloc(44 + dataSize);
    let o = 0;
    buffer.write("RIFF", o); o += 4;
    buffer.writeUInt32LE(36 + dataSize, o); o += 4;
    buffer.write("WAVE", o); o += 4;
    buffer.write("fmt ", o); o += 4;
    buffer.writeUInt32LE(16, o); o += 4;            // subchunk1 size
    buffer.writeUInt16LE(1, o); o += 2;             // PCM
    buffer.writeUInt16LE(numChannels, o); o += 2;
    buffer.writeUInt32LE(sampleRate, o); o += 4;
    buffer.writeUInt32LE(sampleRate * numChannels * bitsPerSample/8, o); o += 4;
    buffer.writeUInt16LE(numChannels * bitsPerSample/8, o); o += 2;
    buffer.writeUInt16LE(bitsPerSample, o); o += 2;
    buffer.write("data", o); o += 4;
    buffer.writeUInt32LE(dataSize, o); o += 4;
    // El resto ya está a cero → silencio
    return buffer;
  }

  app.post("/api/ivr/tts", async (req, res) => {
    try {
      if (!req.isAuthenticated?.() || !req.user?.tenantId) {
        return res.status(401).json({ message: "Authentication required" });
      }

      const { text, voice } = req.body;
      if (!text || typeof text !== "string" || text.trim().length < 10) {
        return res.status(400).json({ message: "Text must be at least 10 characters long" });
      }
      if (!voice || typeof voice !== "object") {
        return res.status(400).json({ message: "Voice configuration is required" });
      }
      const { gender, style } = voice;
      const validGenders = ["hombre", "mujer"];
      const validStyles = ["neutral", "amable", "energetico"];
      if (!validGenders.includes(gender)) {
        return res.status(400).json({ message: `Invalid gender. Must be one of: ${validGenders.join(", ")}` });
      }
      if (!validStyles.includes(style)) {
        return res.status(400).json({ message: `Invalid style. Must be one of: ${validStyles.join(", ")}` });
      }

      // Calcular duración "aprox" y crear carpeta si no existe
      const seconds = Math.min(3, Math.max(2, Math.ceil(Math.min(text.length, 1000) / 20)));
      const uploadsDir = path.resolve("uploads");
      const ivrDir = path.join(uploadsDir, "ivr");
      try { fs.mkdirSync(ivrDir, { recursive: true }); } catch {}

      // Crear WAV silencioso
      const audioId = `ivr_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
      const filePath = path.join(ivrDir, `${audioId}.wav`);
      const wav = makeSilentWav(seconds, 8000);
      await fs.promises.writeFile(filePath, wav);

      const url = `/uploads/ivr/${audioId}.wav`;
      console.log(`🔊 TTS mock -> ${url}`);

      return res.json({
        url,
        text,
        voice: { gender, style },
        duration: seconds,
        audioId,
      });
    } catch (err: any) {
      console.error("❌ IVR TTS error", err);
      return res.status(500).json({ message: err?.message || "TTS error" });
    }
  });

### 3) Reiniciar servidor dev (como antes)
En la pestaña **Shell**:
  pkill -f "server/index.ts" || true
  pkill -f "vite" || true
  sleep 1
  npm run dev

### 4) Verificación rápida
- Abre la UI del IVR -> “Generar audio” y “Escuchar” → debe reproducirse (silencio, pero funciona).
- Si quieres probar directo:
  fetch('/api/ivr/tts', {
    method:'POST',
    headers:{'content-type':'application/json'},
    credentials:'include',
    body: JSON.stringify({ text:'Hola, gracias por llamar', voice:{ gender:'mujer', style:'neutral' } })
  }).then(r=>r.json()).then(d=> new Audio(d.url).play());
